<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <link
      href="style.css"
      rel="stylesheet"
    />
    <title>Blind 75 Tracker</title>
  </head>
  <body>
    <h1>Blind 75 Leetcode Tracker</h1>
    <p>
      Source:
      <a
        href="https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions"
        >https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions</a
      >
    </p>
    <p>Date started: 8/12/2024</p>
    <p>Target completion date: 10/14/2024</p>
    <p>Current count: 61 out of 76 (80%)</p>
    <div class="table-container">
      <div class="row header-row">
        <div class="row-item">#</div>
        <div class="row-item">Question</div>
        <div class="row-item">Date Completed</div>
        <div class="row-item">Approach/Notes</div>
      </div>
      <div class="row">
        <div class="row-item">1</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/two-sum/">Two Sum</a>
        </div>
        <div class="row-item">8/22/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Initialize a dictionary to store complements.</li>
            <li>
              Iterate through the num in nums, if the complement (target - num)
              is found in the complements dictionary, then return the pair of
              indices.
            </li>
            <li>O(n) time O(n) space</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">2</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
            >Best Time to Buy and Sell Stock</a
          >
        </div>
        <div class="row-item">8/11/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Keep track of 2 variables - minimum price seen so far, and max
              profit so far.
            </li>
            <li>
              Iterate through the list of prices, if a lower price is seen,
              update minimum price
            </li>
            <li>
              At each price, calculate the profit with this price, and update
              the max profit if the profit is higher than max profit.
            </li>
            <li>Return max profit</li>
            <li>O(n) time & O(1) space</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">3</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/contains-duplicate/"
            >Contains Duplicate</a
          >
        </div>
        <div class="row-item">8/11/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Initialize a set.</li>
            <li>
              Iterate through the numbers. Check if the number is in the set. If
              it is, return true.
            </li>
            <li>If not, add the number into the set.</li>
            <li>In the end, return false, as there isn't any duplicates.</li>
            <li>O(n) time and O(n) space</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">4</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/product-of-array-except-self/"
            >Product of Array Except Self</a
          >
        </div>
        <div class="row-item">8/13/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Prefix and suffix product</strong></p>
            <li>Initialize 2 arrays of len(nums) and fill with 1'</li>
            <li>
              Store all products of all numbers before nums[i] and products of
              all numbers after nums[i] in the 2 arrays above respectively
            </li>
            <li>
              Multiply each element in the two arrays together and return the
              resulting array.
            </li>
            <li>O(n) time and O(n) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">5</div>
        <div class="row-item">
          &#11088;
          <a href="https://leetcode.com/problems/maximum-subarray/"
            >Maximum Subarray</a
          >
        </div>
        <div class="row-item">8/13/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Dynamic programming - tabulation</strong></p>
            <li>
              Iterate through the list of numbers, at each number, decide
              whether to extend the subarray, or start the subarray from that
              number.
            </li>
            <li>
              If starting a new subarray at that number has a greater value than
              extending the subarray, choose starting a new subarray.
            </li>
            <li>
              At each iteration, keep track of the max sum so far. Return the
              max sum.
            </li>
            <li>O(n) time and O(1) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">6</div>
        <div class="row-item">
          &#11088;
          <a href="https://leetcode.com/problems/maximum-product-subarray/"
            >Maximum Product Subarray</a
          >
        </div>
        <div class="row-item">8/13/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Dynamic programming - tabulation</strong></p>

            <li>Similar to Maximum Subarray problem.</li>
            <li>
              Need to keep track of min_sum and max_sum so far, because number
              could be negative, and need to multiply negative number with the
              min_sum so far to get maximum sum.
            </li>
            <li>O(n) time & O(1) space</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">7</div>
        <div class="row-item">
          &#11088;
          <a
            href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
            >Find Minimum in Rotated Sorted Array</a
          >
        </div>
        <div class="row-item">8/14/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Binary search variation</strong></p>
            <li>
              Initialize two pointers, lo and hi, and calculate mid index.
            </li>
            <li>
              Check if nums at index hi is less than nums at mid index, then the
              minimum is in the right half and vice versa.
            </li>
            <li>Need to watch out for off by one error.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">8</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/search-in-rotated-sorted-array/"
            >Search in Rotated Sorted Array</a
          >
        </div>
        <div class="row-item">8/28/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Binary search variation</strong></p>
            <li>
              Initialize two pointers, lo and hi, and calculate mid index.
            </li>
            <li>
              Check if the target is at either lo, hi or mid. If target is
              found, return the corresponding index.
            </li>
            <li>In a while loop, check which half of the array is sorted.</li>
            <li>
              In the sorted half of the array, if target is in between the
              range, then the target is in this half, otherwise it is in the
              other half. Update pointers accordingly.
            </li>
            <li>Return -1 in the end of target is no in the array.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">9</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/3sum/">3 Sum</a>
        </div>
        <div class="row-item">8/28/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Extension of two sum with sorted array.</li>
            <li>First, sort the input array.</li>
            <li>
              Iterate through the array, and do a two sum on the subarray to the
              right of current num to find the complement.
            </li>
            <li>Skip over any repeating num to avoid duplicate triplets.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">10</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/container-with-most-water/"
            >Container With Most Water</a
          >
        </div>
        <div class="row-item">8/23/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Two pointers</strong></p>
            <li>
              Initialize two pointers, one pointing at each end of the array.
            </li>
            <li>
              Calculate the area between the two pointers = min(height[i],
              height[j]).
            </li>
            <li>Keep track of the maximum area seen so far.</li>
            <li>Move the pointer that has the lower height between the two.</li>
            <li>Return the max area.</li>
            <li>O(n) time and O(1) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">11</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/sum-of-two-integers/"
            >Sum of Two Integers</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">12</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/number-of-1-bits/"
            >Number of 1 Bits</a
          >
        </div>
        <div class="row-item">9/3/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              One line solution. Convert the number to binary using bin(), and
              count the number of 1's using count()
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">13</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/counting-bits/"
            >Counting Bits</a
          >
        </div>
        <div class="row-item">9/3/2024</div>
        <div class="row-item approach">
          <ol>
            <p>2 ways to solve:</p>
            <li>Convert to binary and count the number of 1's.</li>
            <li>
              Use math.log2 for each value of i in range(n) to check if there is
              any remainder.
            </li>
          </ol>
        </div>
      </div>
      <div class="row">
        <div class="row-item">14</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/missing-number/"
            >Missing Number</a
          >
        </div>
        <div class="row-item">9/3/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Sum of all natural numbers up to n (n * (n+1) / 2) minus the sum
              of all the numbers in the array.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">15</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/reverse-bits/">Reverse Bits</a>
        </div>
        <div class="row-item">9/3/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Conver the integer into binary.</li>
            <li>
              Iterate from right to left of the binary string, and multiply it
              starting by 2^31, then 2^30, then 2^29 until index 2 of the binary
              string. Index 0-1 are 0b.
            </li>
            <li>Sum up the total and return it.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">16</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/climbing-stairs/"
            >Climbing Stairs</a
          >
        </div>
        <div class="row-item">8/18/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Recursion with memoization</strong></p>
            <li>
              Base case: When n = 0, we have found a way, return 1. When n &le;
              0, there is no way, return 0.
            </li>
            <li>
              Sum up the return values from recusive calls on n-1 and n-2 (as we
              are only allowed to take 1 or 2 steps).
            </li>
            <p><strong>Dynamic programming with tabulation</strong></p>
            <li>Initialize a dp array with length of n + 1.</li>
            <li>
              Seed: At n = 0, there is 1 way to climb stairs with 0 steps, that
              is to take no step at all.
            </li>
            <li>
              Iterate through the dp array, and add up the ways to climb up n -
              1 and n - 2 steps.
            </li>
            <li>In the end, return dp[-1]</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">17</div>
        <div class="row-item">
          &#11088;
          <a href="https://leetcode.com/problems/coin-change/">Coin Change</a>
        </div>
        <div class="row-item">8/15/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Recursion with memoization</strong></p>
            <li>
              Base case: When amount = 0 , return 0. When amount &le; 0, change
              is not possible, return positive infinity.
            </li>
            <li>
              Recursive case: Loop through each coin, and call the function with
              the amount reduced by the coin amount.
            </li>
            <li>
              Keep track of the minimum number of coin, add one to it, and
              return.
            </li>
            <li>Use a memo to save from doing repeated computation.</li>
            <li>
              Let a = amount, c = number of coins, O(a*c) time and O(a) space
            </li>
            <p><strong>Dynamic programming with tabulation</strong></p>
            <li>Initialize a cache array with length of amount + 1.</li>
            <li>
              Seed the cache at dp[0] = 0, as the min coin to make up 0 is 0.
            </li>
            <li>
              Iterate through the dp cache from 1 to len(dp), and try out each
              coin in the coins list as if it is the last coin we pick.
            </li>
            <li>
              The remaining amount to change after picking that coin will be a
              previous subproblem we already solved.
            </li>
            <li>
              Look for the min coin for the remaining amount and add 1, and if
              it is smaller that what is in the dp table, update the dp table
              with the smaller coin count.
            </li>
            <li>
              Let a = amount, c = number of coins, O(a*c) time & O(a) space.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">18</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/longest-increasing-subsequence/"
            >Longest Increasing Subsequence</a
          >
        </div>
        <div class="row-item">8/18/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Dynamic programming with tabulation</strong></p>
            <li>
              Initialize a dp array with length nums and fill with value 1
              because every individual number has a longest subsequence of 1.
            </li>
            <li>
              Solve with nested for loops. Outer loop will iterate from i = 1 to
              len(dp), inner loop will iterate from j = 0 to i.
            </li>
            <li>
              Compare nums[i](right number) with nums[j] (left number). If the
              right number is greater than the left number, the length of the
              subsequence can be increased. Choose the maximum length to fill in
              dp[i].
            </li>
            <li>In the end, return the largest value in the dp array.</li>
            <li>O(n<sup>2</sup>) time, O(n) space</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">19</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/longest-common-subsequence/"
            >Longest Common Subsequence</a
          >
        </div>
        <div class="row-item">8/18/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Dynamic programming with tabulation</strong></p>
            <li>
              Prepend text1 and text2 with one random but different character in
              the front.
            </li>
            <li>
              Initialize a 2D dp array with len(text1) rows and len(text2)
              columns, filled with 0.
            </li>
            <li>
              Compare characters for the two texts, if the characters are the
              same, add 1 to the LCS[i-1][j-1].
            </li>
            <li>
              If the characters are not the same, then fill dp[i][j] with
              max(dp[i-1][j], dp[i][j-1])
            </li>
            <li>Return dp[-1][-1]</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">20</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/word-break/"
            >Word Break Problem</a
          >
        </div>
        <div class="row-item">8/28/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Recursion with memoization</strong></p>
            <li>
              Create a dictionary where the key is the first character of a
              word, and the value is a list of all the words starting with that
              character.
            </li>
            <li>Use a helper function for the recursive call.</li>
            <li>
              Base cases: (i) If len(s) == 0, then there is a way to break up
              the word. Return True. (ii) If the first character of the string
              is not found in the dictionary, then there isn't a way to break up
              the word. Return False.
            </li>
            <li>
              Recursive case: Get all the words that start with the first
              character from the dictionary. Iterate through the words, and if
              the word don't match the starting of the string, continue to next
              word. Use an OR operation to keep track of whether it is possible
              or not. If only one branch is possible, then there is a way.
            </li>
            <li>Memoize the result.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">21</div>
        <div class="row-item">
          &#11088; &#11088; &#11088;

          <a href="https://leetcode.com/problems/combination-sum/"
            >Combination Sum</a
          >
        </div>
        <div class="row-item">8/16/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Tabulation method most intuitive</strong></p>
            <li>
              Initialize a dp table of length (target + 1). Default value to be
              an empty array [].
            </li>
            <li>
              Seed the value of dp[0] to be an array of an empty array [[]].
              This is because the combination to sum up to 0 is not to choose
              anything.
            </li>
            <li>Iterate through each candidate in the outer for loop.</li>
            <li>
              In the inner for loop, for each candidate, loop through each
              subproblem from candidate up to the end of the dp array. For
              example, if candidate is 2 and the target is 8, then loop from 2
              to 8 inclusive.
            </li>
            <li>
              Key into dp[i - candidate] to see if there are any combination
              that sums up to i - candidate. If there is any, make a copy of the
              combinations, loop through each of the copy of combination, and
              append candidate.
            </li>
            <li>Save all the copies appended with new candidate into dp[i].</li>
            <li>In the end, return the list of combinations of target.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">22</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/house-robber/">House Robber</a>
        </div>
        <div class="row-item">8/18/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Initialize two variables, rob1 and rob2, both to 0. Rob1
              represents profit by robbing the first house, and rob2 represents
              profit by robbing the 2nd house but skipping the first.
            </li>
            <li>
              Iterate through the houses, and calculate the max profit by either
              robbing current house + rob1, or not to rob current house, in
              which the profit is rob2.
            </li>
            <li>Update the variables rob1 = rob2, rob2 = current profit.</li>
            <li>Return rob2.</li>
            <li>O(n) time and O(1) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">23</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/house-robber-ii/"
            >House Robber II</a
          >
        </div>
        <div class="row-item">8/23/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Similar to House Robber I, but run throught the list of houses
              twice, first omitting the first house, and second omitting the
              last house.
            </li>
            <li>Choose the max profit between the 2 runs.</li>
            <li>Guard against list of length 1.</li>
            <li>O(n) time and O(1) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">24</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/decode-ways/">Decode Ways</a>
        </div>
        <div class="row-item">8/26/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Recursion with memoization</strong></p>
            <li>
              Recursively call function with shortened string by first digit and
              by first 2 digits.
            </li>
            <li>
              Check for 2 conditions. First, if the first digit is 0, there is
              no way to decode this string. Return 0. Second, if the first 2
              digit is greater than 26, there is no way to decode this as well.
              But take care not to return too early. Only adjust the return
              value after calling the recursive function.
            </li>
            <li>When the string is empty, we found 1 way to decode it.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">25</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a>
        </div>
        <div class="row-item">8/26/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Recursion with memoization</strong></p>
            <li>
              Base case: When m == 1 and n == 1, you have reached the
              destination, return 1. Base case 2: When either m == 0 or n == 0,
              there is no path, return 0.
            </li>
            <li>
              Recursively call the function by either decreasing the row (move
              down) or decreasing the column (move right).
            </li>
            <li>The sum of all the return count is the solution.</li>
            <p><strong>Dynamic programming with abulation</strong></p>
            <li>Create a 2-D array with m rows and n columns.</li>
            <li>Seed initial values to 1.</li>
            <li>
              Iterate from penultimate row and penultimate column. Update
              dp[row][col] = dp[row+1][col] + dp[row][col+1].
            </li>
            <li>Return dp[0][0].</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">26</div>
        <div class="row-item">
          &#11088;

          <a href="https://leetcode.com/problems/jump-game/">Jump Game</a>
        </div>
        <div class="row-item">8/23/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              It is tempting to use dynamic programming, but a simple for loop
              is much more elegant and efficient.
            </li>
            <li>
              Think of every num is a gas station with num gallons of gas. Start
              with your gas tank empty.
            </li>
            <li>
              As you arrive at each gas station, you can fill up to the maximum
              of your gas level now or the available gas at the gas station.
            </li>
            <li>
              Reduce one gallon of gas as you move to each successive gas
              station.
            </li>
            <li>
              If at any point, your gas is negative, then it is not possible to
              move further, return False.
            </li>
            <li>
              After iterating through every nums / gas station, you have reached
              the end. Return True.
            </li>
            <li>O(n) time, O(1) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">27</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/clone-graph/">Clone Graph</a>
        </div>
        <div class="row-item">8/26/2024</div>
        <div class="row-item approach">
          <ul>
            <p>2 steps approach:</p>
            <li>
              First, iterate through all nodes of the graph, create a clone of
              each node and store the reference to the nodes in a dictionary,
              with key as the node value, and value as the reference to the
              node.
            </li>
            <li>
              Second, iterate through all the nodes of the original graph again,
              and create the links in the cloned nodes.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">28</div>
        <div class="row-item">
          &#11088; &#11088; &#11088;
          <a href="https://leetcode.com/problems/course-schedule/"
            >Course Schedule</a
          >
        </div>
        <div class="row-item">8/29/2024</div>
        <div class="row-item approach">
          <ul>
            <p>
              <strong
                >Topological Sort. White-Grey-Black Cycle Detection
                Algorithm.</strong
              >
            </p>
            <li>
              Create an adjacency list where key is the course, and the value is
              a list of prerequisites.
            </li>
            <li>
              Iterate over the keys of the adjacency list (the white set), and
              perform DFS.
            </li>
            <li>
              Keep track of courses that we have explored fully in previous DFS
              round, call it the visited set (or the black set).
            </li>
            <li>
              Keep track of courses that are visited in the current DFS round,
              call it visiting set, (or the grey set). If we loop back to a
              course that is in the visiting set, then there is a cycle. Return
              False immediately.
            </li>
            <li>
              If have not returned False, then add the course to the visited
              set, and return True to the main calling function.
            </li>
            <li>
              In the main function, if at any point the DFS function return
              False, then return False immediately, no need to continue.
            </li>
            <li>
              When we have processed all the courses in the white set and still
              have not returned False, then return True.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">29</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/pacific-atlantic-water-flow/"
            >Pacific Atlantic Water Flow</a
          >
        </div>
        <div class="row-item">9/3/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Create 2 deques, one for pacific and one for atlantic. Fill the
              pacific deque with coordinates with (0, j), and (i, 0) and
              atlantic deque with coordinates (len(matrix) - 1, j) and (i,
              len(matrix[0]) - 1)
            </li>
            <li>
              Create a helper function called "reacheable" that takes in a queue
              deque. Perform BFS and add all the coordinates that are reachable
              to pacific in a pacific_set and all the coordinates that are
              reachable to the atlantic in an atlantic_set.
            </li>
            <li>
              Find the intersection between pacific_set and atlantic_set and
              return the list.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">30</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/number-of-islands/"
            >Number of Islands</a
          >
        </div>
        <div class="row-item">8/29/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Iterate through each cell in the grid, if the cell is land, then
              explore the island using either BFS or DFS.
            </li>
            <li>DFS' code is much simpler and less prone to error.</li>
            <li>
              While doing DFS, change the cell value from "1" to "0" to mark as
              visited.
            </li>
            <li>When DFS returns, simply increment the island count by 1.</li>
            <li>Return island count.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">31</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/longest-consecutive-sequence/"
            >Longest Consecutive Sequence</a
          >
        </div>
        <div class="row-item">8/23/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Use a heap data structure</strong></p>
            <li>If nums list is empty, return 0.</li>
            <li>
              Heapify the nums list with heapq.heapify. Heapify has O(n) time
              complexity.
            </li>
            <li>
              Initialize two counter variables, current_count and max_count.
            </li>
            <li>Pop from the top of the heap to get the minimim value.</li>
            <li>While the nums heap is not empty, pop a second value.</li>
            <li>
              Compare the first value and the second value. If second = first +
              1, the sequence length is extended. Increment the current_count
              and update the max_count.
            </li>
            <li>
              If second > first + 1, current sequence is terminated. Reset the
              current_count to 1.
            </li>
            <li>
              Replace the first value with the second value, and while loop
              continues.
            </li>
            <li>Return max_count.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">32</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/alien-dictionary/"
            >Alien Dictionary (Leetcode Premium)</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">33</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/graph-valid-tree/"
            >Graph Valid Tree (Leetcode Premium)</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">34</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/"
            >Number of Connected Components in an Undirected Graph (Leetcode
            Premium)</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">35</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/insert-interval/"
            >Insert Interval</a
          >
        </div>
        <div class="row-item">9/1/2024</div>
        <div class="row-item approach">
          <ol>
            <p><strong>3 steps:</strong></p>
            <li>
              Append all intervals which start time is earlier than the start
              time of the new interval into a result list.
            </li>
            <li>
              Merge the new interval into the result list. If the new interval
              start time is after the end time of the last interval in the
              result list, then simply append the new interval. However, if the
              start time of the new interval is before the end time of the last
              interval, then there is an overlap. Update the end time of the
              last interval to the max(end time of new interval, end time of
              last interval).
            </li>
            <li>
              After inserting the new interval, Append all remaining intervals
              to the result list. Return result list.
            </li>
          </ol>
        </div>
      </div>
      <div class="row">
        <div class="row-item">36</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/merge-intervals/"
            >Merge Intervals</a
          >
        </div>
        <div class="row-item">9/1/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Similar approach to Insert Interval</strong></p>
            <li>First, sort the intervals by start time.</li>
            <li>Seed the result list with the first interval.</li>
            <li>
              For each interval, compare the start time to the end time of the
              last interval. If they overlap, update the end time of the last
              interval to the max(end time of last interval, end time of current
              interval).
            </li>
            <li>
              If they don't overlap, simply append the new interval to the
              result list. Return result list.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">37</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/non-overlapping-intervals/"
            >Non-overlapping Intervals</a
          >
        </div>
        <div class="row-item">9/1/2024</div>
        <div class="row-item approach">
          <ul>
            <p>
              <strong
                >Greedy approach. A variation of the Activity Scheduling Problem
                in CS325</strong
              >
            </p>
            <li>Sort the intervals by end time.</li>
            <li>Keep track of the latest end time.</li>
            <li>
              Loop through each of the interval, if the start time is earlier
              than the lastest end time, there is an overalp and the interval
              needs to be removed. Increment a counter.
            </li>
            <li>
              If they don't overlap, no need to remove any interval, simply
              update the max end time.
            </li>
            <li>Return the counter.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">38</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/meeting-rooms/"
            >Meeting Rooms (Leetcode Premium)</a
          >
        </div>
        <div class="row-item">9/27/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Sort the intervals by start time.</li>
            <li>Initialize a current end time variable.</li>
            <li>
              Iterate through the sorted list, if the start time is before
              current end time, return False.
            </li>
            <li>Otherwise, update the end time.</li>
            <li>
              In the end, return True because none of the meetings have
              conflict.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">39</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/meeting-rooms-ii/"
            >Meeting Rooms II (Leetcode Premium)</a
          >
        </div>
        <div class="row-item">9/27/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Line Sweep Method</strong></p>
            <li>
              Assign a label to start and end. E.g. True for start time, False
              for end time.
            </li>
            <li>
              Iterate through the intervals, push the tuple (start_time, label),
              (end_time, label) into a min heap.
            </li>
            <li>Initialize two variables, count, and max count.</li>
            <li>While the heap is not empty, pop from the top of the heap.</li>
            <li>
              If it is a start time, increment count, and keep track of the max
              count so far.
            </li>
            <li>If it is an end time, decrement count.</li>
            <li>In the end, return max count.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">40</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/reverse-linked-list/"
            >Reverse a Linked List</a
          >
        </div>
        <div class="row-item">8/14/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Keep track of a previous node and current node.</li>
            <li>
              Save the next node in a temp variable before changing the
              current.next pointer to previous.
            </li>
            <li>
              Keep changing current.next pointer until current is None, then
              return previous.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">41</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/linked-list-cycle/"
            >Detect Cycle in a Linked List</a
          >
        </div>
        <div class="row-item">8/14/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Hare and tortoise method</strong></p>
            <li>Initialize two pointers, slow and fast.</li>
            <li>
              Move the slow pointer by 1 node, and the fast pointer by 2 nodes.
            </li>
            <li>If the two pointers meet, then there is a cycle.</li>
            <li>No cycle if reach end of the linked list.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">42</div>
        <div class="row-item">
          &#11088;
          <a href="https://leetcode.com/problems/merge-two-sorted-lists/"
            >Merge Two Sorted Lists</a
          >
        </div>
        <div class="row-item">8/14/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Create temp head</strong></p>
            <li>
              While both list are not empty, compare the front of the two list,
              whichever is smaller, point the tempHead to that node, and move
              the current pointer to next.
            </li>
            <li>
              Once exited the while loop, one of the list might still have
              values, if it is, append to the end of the list, and return
              tempHead.next
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">43</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/merge-k-sorted-lists/"
            >Merge K Sorted Lists</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">44</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
            >Remove Nth Node From End Of List</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">45</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/reorder-list/">Reorder List</a>
        </div>
        <div class="row-item">9/14/2024</div>
        <div class="row-item approach">
          <ul>
            <p>
              <strong
                >Method 1: Use a dictionary to store pointer to all
                nodes</strong
              >
            </p>
            <li>
              Create a dictionary that stores the position as the key, and the
              node pointer as the value.
            </li>
            <li>
              Iterate through first half of the list, and point to the second
              half using index arithmetic.
            </li>
            <li>
              Then iterate through second half of the list, and point to the
              first half of the list using index arithmetic.
            </li>
            <li>Slight difference in index for odd and even length list.</li>
            <li>Point the middle node to None.</li>
            <li>O(n) time and O(n) space.</li>
            <p>
              <strong
                >Method 2: Reverse 2nd half of list and weave two lists.</strong
              >
            </p>
            <li>O(n) time and O(1) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">46</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/set-matrix-zeroes/"
            >Set Matrix Zeroes</a
          >
        </div>
        <div class="row-item">9/2/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Use the row 0 and column 0 to indicate whether that row/col need
              to be set to zeroes.
            </li>
            <li>
              Start iterating for row 1 and col 1, if encountered a zero, then
              set the indicating row to zero.
            </li>
            <li>
              Iterate for the second time from row 1 and col 1, if corresponding
              top row and top col is zero, that means set this cell as zero.
            </li>
            <li>
              Finally, check if the col 0 and row 0 need to be set to zero. This
              is indicated by 2 boolean variables.
            </li>
            <li>O(1) space and O(mn) time</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">47</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/spiral-matrix/"
            >Spiral Matrix</a
          >
        </div>
        <div class="row-item">9/17/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              In a while-loop, run 4 for-loops that turns down, left, up and
              right.
            </li>
            <li>
              After each turn, depending on the turn, either increase min_row or
              min_col or decrease max_row or max_col.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">48</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/rotate-image/">Rotate Image</a>
        </div>
        <div class="row-item">9/18/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Approach 1: Move each element by 90 degree </strong></p>
            <li>
              Move item from (r, c) to (c, n - r - 1) repeatedly 4 times (1 for
              each corner), starting from outer perimeter to inner.
            </li>
            <li>
              Iterate from row 0 to row n // 2, and from col=r to col = n - r -
              1.
            </li>
            <p>
              <strong
                >Approach 2: First flip the matrix on vertical axis, then flip
                across the main diagonal</strong
              >
            </p>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">49</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/word-search/">Word Search</a>
        </div>
        <div class="row-item">9/7/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>DFS and backtracking</strong></p>
            <li>
              Iterate through every cell, once found a cell which character
              match the first letter of the word, call a helper function.
            </li>
            <li>
              Helper function will search all neighbors with DFS algorithm, and
              backtrack if did not match.
            </li>
            <li>
              Once all the letters are matched, return True. If no match is
              found after iterating through all cells, return False
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">50</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/longest-substring-without-repeating-characters/"
            >Longest Substring Without Repeating Characters</a
          >
        </div>
        <div class="row-item">9/18/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Hashmap and sliding window</strong></p>
            <li>
              Use a hashmap to store the index of when a character is last seen.
            </li>
            <li>
              Initialize two variables to keep track of the start of a sliding
              window and the longest non-repeating substring seen so far.
            </li>
            <li>
              Iterate over the string, if seen this character before, then
              update the start of the window to forget about all the character
              up to when this character was previously seen.
            </li>
            <li>
              At every iteration, update the longest non repeating substring,
              and update the seen hashmap with the latest index.
            </li>
            <li>Return the longest variable.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">51</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/longest-repeating-character-replacement/"
            >Longest Repeating Character Replacement</a
          >
        </div>
        <div class="row-item">9/19/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Hashmap and sliding window</strong></p>
            <li>
              Initializa a frequency hashmap to keep track of the frequency of
              each char in the string seen so far.
            </li>
            <li>
              Initialize 3 variables to keep track of (1) the start of the
              sliding window, (2) the longest substring so far, (3) the
              frequency of the most frequent character
            </li>
            <li>
              Iterate over the string to denote the end of the sliding window,
              and update the frequency of the hashmap
            </li>
            <li>
              Update the top frequency variable since that might have changed.
            </li>
            <li>
              Calculate the size of the window, and minus the top frequency.
              That will give the remaining number of characters that are not the
              most frequent.
            </li>
            <li>
              If the remaining is less than or equals to k, then this is a valid
              substring. So update the longest variable.
            </li>
            <li>
              Otherwise, advance the left pointer and reduce the frequency of
              the character that is now out of the sliding window.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">52</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/minimum-window-substring/"
            >Minimum Window Substring</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">53</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/valid-anagram/"
            >Valid Anagram</a
          >
        </div>
        <div class="row-item">8/12/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Count the frequency of characters for both strings, and compare if
              they are the same.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">54</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/group-anagrams/"
            >Group Anagrams</a
          >
        </div>
        <div class="row-item">8/12/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Sort each string, and store in a dictionary with the sorted string
              as the key, and the value as a list of strings.
            </li>
            <li>Return all the values in the dictionary.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">55</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/valid-parentheses/"
            >Valid Parentheses</a
          >
        </div>
        <div class="row-item">8/11/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Initialize a stack data structure.</li>
            <li>
              Create a dictionary that stores pairs of brackets. Key as the
              closing bracket, and the value is the corresponding opening
              bracket.
            </li>
            <li>Loop over each character in the string.</li>
            <li>
              If the character is an opening bracket, push it onto the stack.
            </li>
            <li>
              Else, if the character is a closing bracket, check if the stack is
              empty. If the stack is empty, then there isn't a corresponding
              opening bracket, and the string is invalid. If the stack is not
              empty, pop the topmost item in the stack, and check if they match.
              If they don't, then return false.
            </li>
            <li>
              After finish looping through every character in the string, if the
              stack is not empty, then it is invalid.
            </li>
            <li>Else, return true. The string is valid parenthesis.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">56</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/valid-palindrome/"
            >Valid Palindrome</a
          >
        </div>
        <div class="row-item">8/11/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Use a two pointers, i and j. i pointing at the beginning of the
              string, j pointing at the end.
            </li>
            <li>
              Check if the characters at the two pointers are alphanumeric, if
              not, then skip that character.
            </li>
            <li>
              Check if the two characters are the same. If they are not, then
              invalid palindrome.
            </li>
            <li>
              When the two pointers crossed, it means we have examined all
              characters, and it is a valid palindrome.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">57</div>
        <div class="row-item">
          &#11088;
          <a href="https://leetcode.com/problems/longest-palindromic-substring/"
            >Longest Palindromic Substring</a
          >
        </div>
        <div class="row-item">8/13/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Iterate through each character of the string. For each character,
              look to the left and to the right of the string and check if it is
              a palindrome.
            </li>
            <li>
              Keep track of the length of the longest palindome seen so far, and
              the palindrom itself.
            </li>
            <li>
              If found a longer palindrome, update the length and the longest
              palindrom.
            </li>
            <li>Make sure to check for both even and odd length palindrome.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">58</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/palindromic-substrings/"
            >Palindromic Substrings</a
          >
        </div>
        <div class="row-item">8/13/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              This is a variation of the Longest Palindromic Substring problem.
            </li>
            <li>
              Instead of keeping track of the longest substring, keep track of
              the count.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">59</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/encode-and-decode-strings/"
            >Encode and Decode Strings (Leetcode Premium)</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">60</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/"
            >Maximum Depth of Binary Tree</a
          >
        </div>
        <div class="row-item">8/22/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Recursively call left child and right child if they are not None.
            </li>
            <li>
              Once encounter a leaf node (left and right child are both None),
              return 1.
            </li>
            <li>
              Return 1 + the maximum return value from left and right subcall.
            </li>
            <li>Remember to check for empty root.</li>
            <li>
              O(n) time (visiting every node), and O(log n) space (max height of
              tree)
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">61</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/same-tree/">Same Tree</a>
        </div>
        <div class="row-item">8/13/2024</div>
        <div class="row-item approach">
          <ol>
            <li>
              Iterative breadth first search
              <ul>
                <li>Initialize two queues - p_queue and q_queue.</li>
                <li>
                  While both queues are not empty, pop the nodes from the front
                  of the queues, and compare them, including null.
                </li>
                <li>
                  After exiting the while loop, check if both queues are empty.
                  If one is empty and the other is not, then it's not the same
                  tree.
                </li>
                <li>Return true in the end.</li>
                <li>
                  O(|p| + |q|) time and space, |p| = # of nodes in p, |q| = # of
                  nodes in q
                </li>
              </ul>
            </li>
            <li>Recursion</li>
            <ul>
              <li>Simpler and shorter code.</li>

              <li>
                Base cases: If both p and q are None, return true. If only one
                is None, return false.
              </li>
              <li>
                If both are not None, then check if the values are the same.
              </li>
              <li>Call function recursively on both left and right child.</li>
              <li>
                O(|p| + |q|) time & O(h) space, |p| = # of nodes in p, |q| = #
                of nodes in q, h = max height of the tree
              </li>
            </ul>
          </ol>
        </div>
      </div>
      <div class="row">
        <div class="row-item">62</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/invert-binary-tree/"
            >Invert/Flip Binary Tree</a
          >
        </div>
        <div class="row-item">8/22/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Base case: return None if root is None.</li>
            <li>
              Assign root.left to the return value of recursive call on
              root.right.
            </li>
            <li>
              Assign root.right to the return value of recursive call on
              root.left
            </li>
            <li>Return root.</li>
            <li>O(n) time and O(log n) space.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">63</div>
        <div class="row-item">
          &#11088; &#11088; &#11088;

          <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/"
            >Binary Tree Maximum Path Sum</a
          >
        </div>
        <div class="row-item">8/23/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Depth First Search</strong></p>
            <li>Keep track of max_sum so far with a global variable.</li>
            <li>
              Use a helper recursive function to call on the left subtree and
              the right subtree.
            </li>
            <li>
              On reach recursive call, keep track of the maximum of either (i)
              max sum so far, (ii) root.val + left, (iii) root.val + right, (iv)
              root.val + left + right, (v) root.val
            </li>
            <li>
              Retun only either (i) root.val, (ii) root.val + left, (iii)
              root.val + right
            </li>
            <li>In the main function, return the global variable max_sum</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">64</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/binary-tree-level-order-traversal/"
            >Binary Tree Level Order Traversal</a
          >
        </div>
        <div class="row-item">8/22/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Breadth First Search</strong></p>
            <li>Check if root is None. If root is None, return [].</li>
            <li>Use BFS. Initialize a queue with a tuple (root, level = 0)</li>
            <li>Initializea result array.</li>
            <li>
              While queue is not empty, pop a tuple from the front of the queue.
            </li>
            <li>
              If len(result) is greater than level, then append the current
              value into result[level].
            </li>
            <li>
              Otherwise, append a new array containing current value to the
              result array.
            </li>
            <li>
              For both left and right child, check if they are not None. If not
              None, then append the tuple (childnode, level + 1) to the queue.
            </li>
            <li>Return result.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">65</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"
            >Serialize and Deserialize Binary Tree</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">66</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/subtree-of-another-tree/"
            >Subtree of Another Tree</a
          >
        </div>
        <div class="row-item">8/22/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>Depth first search</strong></p>
            <li>
              Compare the values of root and subroot, if they are the same, call
              a subroutine to check if they are the same tree.
            </li>
            <li>
              If the values of root and subroot are not the same, then
              recursively call on left and right children of root, but keep
              subroot the same.
            </li>
            <li>
              Be careful to not return too early when calling the subroutine.
              Check all child nodes to see if they are the same trees with
              subroot before returning.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">67</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
            >Construct Binary Tree from Preorder and Inorder Traversal</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">68</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/validate-binary-search-tree/"
            >Validate Binary Search Tree</a
          >
        </div>
        <div class="row-item">8/22/2024</div>
        <div class="row-item approach">
          <ul>
            <li>
              Use a helper function to recursively vall left subtree and right
              subtree.
            </li>
            <li>
              Base case 1: Root is None, return a tuple of 3 elements (True,
              inf, -inf). The tuple value represents (BST is valid, min value in
              subtree, max value in subtree).
            </li>
            <li>
              Base case 2: Reached a leaf node, a leaf node is always a valid
              BST, min and max value of a tree with only one node is the value
              of the node itself. So, return (True, root.val, root.val)
            </li>
            <li>
              Call left subtree and right subtree. From the return values of
              both calls, check that root.val is greater than max val from left
              subtree and less than the min val from the right subtree.
            </li>
            <li>
              Return a tuple (True/False, min(left_min, root.val), max(root.val,
              right_max))
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">69</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
            >Kth Smallest Element in a BST</a
          >
        </div>
        <div class="row-item">8/22/2024</div>
        <div class="row-item approach">
          <ul>
            <p><strong>In Order Traversal</strong></p>
            <li>
              Use a helper function to traverse the tree in-order and save the
              values in an array. With in order traversal, the values will be
              sorted.
            </li>
            <li>Return the value at index k - 1.</li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">70</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
            >Lowest Common Ancestor of BST</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">71</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/implement-trie-prefix-tree/"
            >Implement Trie (Prefix Tree)</a
          >
        </div>
        <div class="row-item">9/11/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Use a dictionary to implement the trie.</li>
            <li>
              For insert, if the first character is not one of the key, then add
              the key and an empty dictionary as value.
            </li>
            <li>
              If the first character is one of the key, then key into it and
              continue checking for the 2nd character and so on.
            </li>
            <li>
              Continue until the end of the word. Add the key True to indicate
              that this is the end of one string.
            </li>
            <li>
              Similar approach for search. Check if the first character is in
              the key. If not found, means the word is not in the trie. If
              found, then continue searching for 2nd character and so on until
              the end of the word.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">72</div>
        <div class="row-item">
          <a
            href="https://leetcode.com/problems/add-and-search-word-data-structure-design/"
            >Add and Search Word</a
          >
        </div>
        <div class="row-item">9/11/2024</div>
        <div class="row-item approach">
          <ul>
            <li>Similar approach to "Implement Trie (Prefix Tree)" question</li>
            <li>
              When encountered the wildcard character ".", iterate through all
              the keys and search for word in each subtree.
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="row-item">73</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/word-search-ii/"
            >Word Search II</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">74</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/merge-k-sorted-lists/"
            >Merge K Sorted Lists</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">75</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/top-k-frequent-elements/"
            >Top K Frequent Elements</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">76</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/find-median-from-data-stream/"
            >Find Median from Data Stream</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach"></div>
      </div>
      <div class="row">
        <div class="row-item">77</div>
        <div class="row-item">
          <a href="https://leetcode.com/problems/coin-change-ii/"
            >Coin Change II</a
          >
        </div>
        <div class="row-item"></div>
        <div class="row-item approach">
          <ul>
            <p><strong>Dynamic programming with tabulation</strong></p>
            <li>Create a dp array of length (amount + 1).</li>
            <li>
              Seed dp[0] = 1, there is 1 way to make up amount 0, is to select
              none of the coins.
            </li>
            <li>
              Iterate over the coin first, then iterate over the amount
              subproblem.
            </li>
            <a href="https://www.youtube.com/watch?v=OM1myudbIqA">Reference.</a>
          </ul>
        </div>
      </div>
    </div>
    <h3>Progress</h3>
    <div class="table-container">
      <div class="progress-row header-row">
        <div class="row-item">Week #</div>
        <div class="row-item">End Date</div>
        <div class="row-item">Target</div>
        <div class="row-item">Actual</div>
        <div class="row-item">Actual / Target</div>
      </div>

      <div class="progress-row">
        <div class="row-item">1</div>
        <div class="row-item">08-19-2024</div>
        <div class="row-item">15</div>
        <div class="row-item">22</div>
        <div class="row-item">147%</div>
      </div>

      <div class="progress-row">
        <div class="row-item">2</div>
        <div class="row-item">08-26-2024</div>
        <div class="row-item">30</div>
        <div class="row-item">36</div>
        <div class="row-item">120%</div>
      </div>

      <div class="progress-row">
        <div class="row-item">3</div>
        <div class="row-item">09-02-2024</div>
        <div class="row-item">45</div>
        <div class="row-item">45</div>
        <div class="row-item">100%</div>
      </div>

      <div class="progress-row">
        <div class="row-item">4</div>
        <div class="row-item">09-09-2024</div>
        <div class="row-item">50</div>
        <div class="row-item">52</div>
        <div class="row-item">104%</div>
      </div>

      <div class="progress-row">
        <div class="row-item">5</div>
        <div class="row-item">09-16-2024</div>
        <div class="row-item">55</div>
        <div class="row-item">55</div>
        <div class="row-item">100%</div>
      </div>

      <div class="progress-row">
        <div class="row-item">6</div>
        <div class="row-item">09-23-2024</div>
        <div class="row-item">65</div>
        <div class="row-item">59</div>
        <div class="row-item">91%</div>
      </div>
      <div class="progress-row">
        <div class="row-item">7</div>
        <div class="row-item">09-30-2024</div>
        <div class="row-item">65</div>
        <div class="row-item"></div>
        <div class="row-item"></div>
      </div>

      <div class="progress-row">
        <div class="row-item">8</div>
        <div class="row-item">10-07-2024</div>
        <div class="row-item">70</div>
        <div class="row-item"></div>
        <div class="row-item"></div>
      </div>
      <div class="progress-row">
        <div class="row-item">9</div>
        <div class="row-item">10-14-2024</div>
        <div class="row-item">76</div>
        <div class="row-item"></div>
        <div class="row-item"></div>
      </div>
    </div>
  </body>
</html>
